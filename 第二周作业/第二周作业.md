 第二周作业
	- 由Java虚拟机所管理的内存包含以下几个运行时数据区，由是否线程共享可分为两类：
		- 线程独享
			- 程序计数器（Program Counter Register）：
				- 可以看作当前线程所执行的字节码的行号指针。我们需要它来实现例如循环，异常处理，线程恢复等等基础功能。
			- Java虚拟机栈（Java Virtual Machine Stack）：
				- 每个方法被执行时，Java虚拟机会创建一个栈帧（Stack Frame）来存储局部变量表，操作数栈，动态链接和方法返回地址等信息。每个方法从被调用到执行完毕的过程，都对应着一个栈帧在虚拟机中从入栈到出栈的过程。
			- 本地方法栈（Native Method Stack）：
				- 与虚拟机栈作用类似，区别在于本地方法栈为虚拟机使用的本地方法服务。
		- 线程共享
			- Java堆 （Java Heap）
				- 存在目的：存放对象实例
				- 由垃圾收集器管理
			- 方法区（Method Area）
				- 存储编译后的类的结构信息，例如运行时常量池，字段和方法数据等
				- 方法区和永久代并不是等价的，JDK1.8之前，HotSpot使用永久代来实现方法区，但是在JDK1.8之后，永久代的概念已被废弃，转而使用在本地物理内存中实现的元空间（Meta-Space）来替代。
				- 运行时常量池（Runtime Constant Pool）
					- 存放常量池表（Constant Pool Table），即编译生成的各种字面量（Literal）与符号引用（Symbolic Reference）
			- 直接内存
				- 由JDK1.4新加入的NIO（New Input/Output）引入的基于通道（Channel）和缓冲区（Buffer）的I/O方式可以直接使用Native方法分配堆外内存。
					- 优点，在一些场景中显著提高性能
	- 为什么堆内存要分年轻代和老年代
		- 多数常用的虚拟机所使用的垃圾收集器都遵循了分代收集（Generational Collection）的理论进行设计，这一理论来自于符合大多数程序实际巡行情况的实际经验，总结为两个分带假说：
			- 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。
			- 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越不会被收集。
		- 根据这两个假说，常用的垃圾收集器都使用了类似的设计原则，即将Java堆划分成不同区域，然后将回收对象依据其年龄（熬过垃圾回收的次数）分配到不同的区域中存储。年轻代用来存放朝生夕灭的对象，而每次回收后存活的对象，将会逐步晋升到老年代中存放。
	- Java 对象的生命周期
		- 解释一个对象的创建过程
			- HotSpot虚拟机的对象创建流程：
				- Java虚拟机接收到new指令
				- 检查这个指令的参数能否在常量池中定位到一个类的符号引用，以及这个符号引用所指的类是否已被加载，如果没有，则执行相应的类加载过程
				- 分配内存
					- 指针碰撞（Bump The Pointer）
						- 针对内存地址是连续的情况
						- 指针只需向空闲方向挪动一段与对象大小相等的距离
						- 内存地址是否连续由垃圾收集器是否带有空间压缩整理（Compact）能力决定，当使用Serial，ParNew等待压缩整理过程的收集器时，分配算法为指针碰撞。
					- 空闲列表（Free List）
						- 针对内存地址不连续的情况
						- 虚拟机维护一个列表，记录那些内存空间可用，分配时从列表中找到一块足够大的空间分配给对象，并更新列表
						- 当垃圾收集器使用CMS这种基于清除（Sweep）算法的收集器时，分配算法为空闲列表
				- 虚拟机将分配到的内存空间初始化为零值
				- 必要信息设置，例如对象是哪个类的实例，如何才能找到类的元数据信息对象的哈希码，对象的GC分代年龄的信息
				- 执行Class文件中init方法，即构造方法
		- 解释一个对象的内存分配
			- 除了如何划分可用空间外，还需考虑线程安全问题，以指针碰撞为例，在给对象A分配内存时，指针还没来得及修改其位置，对象B使用了原来的指针来分配内存。
			- 解决方案：
				- 同步处理，CAS（乐观锁）加上失败重试的方式保证更新操作的原子性
				- 按照线程将内存分配的动作划分，即每个线程在Java堆中预先分配一块内存， 成为本地线程分配缓冲（Thread Local Allocation Buffer，TLAB），每个线程先在自己的本地缓冲区中分配内存，用完之后才需要在分配新的缓存区进行同步操作。
		- 对象的 2 种访问方式是什么？
			- 主要有两种：
				- 句柄
					- Java堆中将会划分出一块内存来作为句柄池，Java栈中的本地变量表里的reference中存储的就是对象的句柄地址，而句柄中包含了对象示例数据和类型数据各自的地址信息
					- 优点：reference中存储的时稳定的句柄地址，对象在被移动时（比如在垃圾回收时可能会被移动）只需改变聚丙种的示例数据指针
				- 直接指针
					- Java堆中对象的内存布局必须考虑如何放置访问类型数据的相关信息，reference中存储的就是对象地址
					- 优点：访问速度快，节省了一次指针定位的时间开销
		- 为什么需要内存担保？
			- 当新生代无法给新对象分配内存时，虚拟机将新生代中的老对象转移到老年代，这样新生代就可能有足够的空间给新对象，这种机制叫做内存担保
			- 大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够的空间时，虚拟机将发起一次Minor GC
			- 在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代的所有对象大小的总和。
				- 如果成立，那这一次Minor GC是安全的
				- 如果不成立，查看-XX: HandlePromotionFailure是否允许担保失败（Handle Promotion Failure）
					- 如果允许，检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小
						- 如果大于，尝试Minor GC
						- 如果小于，或者-XX: HandlePromotionFailure设置为不允许冒险，则Full GC
	- 垃圾收集算法有哪些？
		- 跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。
		- 标记-清除（Mark-Sweep）算法
			- 首先标记出所有需要回收的对象，标记完成后，统一回收掉所有被标记的对象
			- 缺点：
				- 效率不稳定，标记和清除的执行效率随对象数量增长而降低
				- 内存空间会因标记清除而产生大量不连续的碎片，从而导致大对象无法分配而提前出发垃圾回收
		- 标记-复制（Semispace Copying）算法
			- 将可用内存容量划分为大小相等的两块，每次只使用其中的而一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把一使用过的内存空间一次清理掉
			- 主要用于回收新生代
		- 标记-整理（Mark-Compact）算法
			- 主要用于老年代
			- 标记之后，所有存活的对象都想内存空间一端移动，然后直接清理掉边界以外的内存
	- 垃圾收集器有哪些？他们的特点是什么？
		- 串行收集器：执行垃圾收集时，暂停其他所有工作线程
			- 年轻串行（Serial）：复制算法
			- 老年串行（Serial Old）：标记整理算法
			- 适用情况：客户端模式下的虚拟机
		- 并行收集器
			- ParNew收集器：多线程并行版的Serial收集器
				- 适用情况：多核处理器，服务器端模式下的虚拟机，与CMS收集器配合的很好
				- 官方希望被G1取代
			- Parallel Scavenge 收集器
				- 目标：可控的吞吐量（Throughput），即处理器用于运行用户代码的时间与处理器总消耗时间的比值
				- 适用情况：在后台运算而不需要太多交互的分析任务
			- Parallel Old 收集器
				- Parallel Scavenge老年代版本
				- 适用情况：注重吞吐量或者处理器资源较为稀缺的场合，配合Parallel Scavenge使用
			- CMS（Concurrent Mark Sweep） 收集器
				- 目标：回收停顿时间最短
				- 适用情况：互联网站或基于浏览器的B/S系统的服务端
				- 缺点：
					- 对处理器资源非常敏感
					- 无法处理浮动垃圾
					- 会产生大量碎片
			- G1（Garbage First）收集器
				- 里程碑，全功能的垃圾收集器，开创了收集器面向局部收集的设计思路和基于Region的内存布局形式
				- 适用情况：服务端应用，取代了Parallel Scavenge加Parallel Old
				- 特点：
					- 可由用户指定停顿时间
					- 取消了新生代、老年代的物理区分，而是将堆划分为若干区域，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间，从而实现了Mixed GC模式
					- 专门用来存储大对象的Humongous区域
